\subsection{Struttura modulare - Blueprint}
\label{ss:blueprint}

Flask è un \textit{micro‑framework}, ma con l'aumentare della complessità dell'applicazione diventa cruciale adottare una struttura modulare per mantenere il codice chiaro e manutenibile.  
I \textit{blueprint} di Flask permettono di suddividere progetti complessi in componenti riutilizzabili, sviluppabili e mantenibili in modo indipendente, facilitando l'integrazione di nuovi moduli senza riscrivere il progetto principale.  
Essi consentono di raggruppare rotte, \textit{template} e file statici in \textit{mini}‑applicazioni all'interno della stessa istanza Flask. Non sono micro‑framework autonomi, ma \textit{insiemi di operazioni} da registrare sull'app principale, anche più volte.

I principali vantaggi dei \textit{blueprint} sono: \cite{palets_blueprints}

\begin{itemize}
  \item \emph{Modularità e incapsulamento}: ogni \textit{blueprint} racchiude logica e risorse relative a una specifica funzionalità (es. visualizzazione mappa, simulazione propagazione).
  \item \emph{Scalabilità}: consente di estendere l'app aggiungendo moduli senza influire sul codice esistente.
  \item \emph{Gestione centralizzata}: configurazioni e estensioni vengono condivise, pur mantenendo un'organizzazione chiara del progetto.
\end{itemize}


\subsubsection{Esempio di Blueprint}

Un \textit{blueprint} è un'entità modulare dichiarata come illustrato nel Listing \ref{lst:python_blueprint_registration} (es. \texttt{'simple\_page'} importato da \texttt{'templates'}), progettata per incapsulare rotte e risorse di un componente autonomo dell'applicazione.

Dopo la sua definizione, il \textit{blueprint} viene registrato nell'applicazione Flask principale tramite \texttt{app.register\_blueprint()} (Listing \ref{lst:python_blueprint_registration}). Questa operazione lo integra nel contesto runtime dell'applicazione.

Le rotte interne ai \textit{blueprints} sono gestite in modo relativo, prevenendo conflitti di naming con le rotte dell'applicazione principale o di altri \textit{blueprints}. Ciò significa che il percorso completo di una rotta interna dipende dal montaggio del \textit{blueprint}.

Questa gestione relativa permette di \say{montare} il \textit{blueprint} su un percorso \textit{radice} specifico (nell'esempio, su \texttt{/pages} tramite \texttt{url\_PREFIX}), creando un namespace URL logico. Una richiesta a \texttt{<indirizzo principale>/pages} viene quindi internamente instradata al \textit{blueprint}, consentendo un disaccoppiamento che favorisce la modularità e la riusabilità \cite{palets_blueprints}.

\begin{listing}
% \caption{Codice del file \texttt{simple\_page.py} che descrive un blueprint in Flask}
% \label{lst:flask-blueprint} % Il label va all'interno dell'ambiente listing o subito dopo la caption
\begin{minted}{python}
from flask import Blueprint, render_template, abort
from jinja2 import TemplateNotFound

simple_page = Blueprint('simple_page', __name__, template_folder='templates')

@simple_page.route('/<page>')
def show(page):
    try:
        return render_template(f'pages/{page}.html')
    except TemplateNotFound:
        abort(404)
\end{minted}
\caption{Codice del file \texttt{simple\_page.py} che descrive un blueprint in Flask (sopra) e Blueprint \texttt{simple\_page} montata in /pages}
\label{lst:python_blueprint_registration} % Aggiunto un nuovo label per questo secondo blocco
\begin{minted}{python}
from flask import Flask
from simple_page import simple_page

app = Flask(__name__)
app.register_blueprint(simple_page, url_PREFIX='/pages')
\end{minted}
\end{listing}

\subsection{Integrazione del blueprint}

Questo segmento illustra come, in un progetto Flask esterno, sia possibile integrare un sistema di heatmap completo con semplicità ed efficienza. L'approccio segue una filosofia \say{zero-configuration} per la configurazione di base, risultando adatto sia a prototipi rapidi sia ad applicazioni con requisiti standardizzati.

Il fulcro dell'integrazione è la funzione \texttt{register\_heatmap()}. Come mostrato nel codice seguente, basta invocarla passando l'istanza dell'applicazione Flask (\texttt{app}) per abilitare l'intera suite di funzionalità di heatmap. Questa astrazione della complessità consente agli sviluppatori di concentrarsi sulla logica principale del progetto, mentre la gestione del modulo heatmap viene completamente delegata.


\begin{listing}[H]
\caption{Esempio di Integrazione Semplificata della Heatmap in un Progetto Flask}
\label{lst:heatmap_simple_integration}
\begin{minted}{python}
from flask import Flask
from heatmap_blueprint import register_heatmap

app = Flask(__name__)

# Aggiungi qui le tue rotte esistenti
@app.route('/')
def home():
    return "My existing Flask app"

# Aggiungi la funzionalità heatmap
register_heatmap(app)

if __name__ == '__main__':
    app.run(debug=True)
\end{minted}
\end{listing}

A seguito di questa integrazione, supponendo di aver scelto un prefisso per il blueprint (rappresentato dal generico \texttt{URL\_PREFIX}), l'applicazione renderà disponibili automaticamente i seguenti endpoint HTTP, fornendo accesso all'interfaccia utente e ai servizi API della heatmap:

\begin{itemize}
    \item \texttt{http://localhost:5000/} -- Redirect alla dashboard principale.
\end{itemize}

\subsection{Endpoints con Prefisso} % Un sottotitolo per chiarezza
\label{ss:endpoints}

Tutti i seguenti endpoint sono preceduti da \texttt{http://localhost:5000/\{URL\_PREFIX\}/}:

\begin{itemize}
    \item \texttt{} -- Dashboard unificata con heatmap e visualizzazione della propagazione.
    \item \texttt{data} -- Restituisce i dati CSV predefiniti come JSON.
    \item \texttt{data/\{csv\_key\}} -- Restituisce uno specifico dataset come JSON.
    \item \texttt{csv-files} -- Restituisce l'elenco dei file CSV disponibili.
    \item \texttt{config-info} -- Restituisce le informazioni di configurazione e i percorsi auto-rilevati.
    \item \texttt{test-data} -- Testa il caricamento dei CSV e mostra la struttura dei file.
    \item \texttt{static/\{filename\}} -- Serve risorse statiche (auto-rilevate).
\end{itemize}

Questi esempi utilizzano \texttt{http://localhost:5000} per indicare l'indirizzo di accesso locale durante la fase di sviluppo dell'applicazione. L'hostname \texttt{localhost} si riferisce al server in esecuzione sulla macchina locale dello sviluppatore, mentre \texttt{5000} è la porta di default utilizzata dal server di sviluppo integrato di Flask. In un ambiente di produzione, questi URL sarebbero sostituiti dal dominio e dalla porta configurati per il deployment dell'applicazione (es. \texttt{https://mnat.org/heatmap/}).

\newpage
