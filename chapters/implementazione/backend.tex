\section{Analisi dell'Architettura}
\label{ch:backend-architecture}

\subsection{Factory Pattern e Dependency Injection}

Nel backend, è stato adottato il \emph{Factory Pattern} tramite la funzione \texttt{create\_heatmap\_blueprint()}, che genera dinamicamente \textit{blueprint} Flask configurati secondo parametri esterni. Ogni \textit{blueprint} funge da modulo indipendente, montabile o smontabile a seconda delle esigenze, garantendo coerenza e riusabilità del codice \cite{app-factories}. Il concetto di \textit{blueprint} è descritto in dettaglio nella sezione \ref{ss:blueprint}. In questo modo, il backend risulta modulare e adattabile a contesti applicativi diversi, riducendo la necessità di modifiche al codice ospitante.

In combinazione con il Factory Pattern, viene impiegata la \emph{dependency injection}, che permette di fornire componenti esterni (configurazioni, utility) al momento della creazione del modulo. Ciò evita l'uso di variabili globali, migliorando testabilità, flessibilità e manutenibilità del sistema \cite{dependency-injection-wiki,flask-di}.


\input{chapters/implementazione/blueprints}

\input{chapters/implementazione/configurazione}

\input{chapters/flask/pipeline-dati-json}

\input{chapters/flask/modularita}

\subsection{Considerazioni sull'architettura}

L'architettura implementata non è certo priva di limiti, ma si è dimostrata efficace per gli obiettivi di questo lavoro. Il sistema è sufficientemente flessibile da poter essere adattato a scenari diversi, ed è organizzato in modo modulare per facilitare l'estensione futura.


In particolare, l'uso del Factory Pattern e della dependency injection ha reso lo sviluppo più ordinato, mentre la gestione centralizzata delle configurazioni e dei dataset ha permesso di operare con file eterogenei senza richiedere modifiche sostanziali. Tutti questi elementi, sebbene piuttosto semplici presi singolarmente, hanno contribuito a costruire un backend che potrà essere integrato in ambienti di lavoro più complessi.
