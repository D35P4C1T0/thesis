
\subsection{Introduzione al Flusso Dati}

In questo sistema, i dati geospaziali in formato CSV non vengono convertiti in GeoJSON per la visualizzazione; la scelta è stata effettuata per motivi di efficienza, semplicità e adattabilità architetturale.

\begin{table}[H]
\centering
\caption{Heatmap e supporto GeoJSON nelle librerie considerate}
\label{tab:geojson-heatmap-compact}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Libreria} & \textbf{GeoJSON richiesto} & \textbf{Formato dati accettato} \\ \midrule
Leaflet & No & Array \texttt{[lat, lng, weight]} (via plugin) \\
Deck.gl & No & Oggetti JS con coordinate e peso \\
Folium & No & Lista o DataFrame (via Python) \\
Mapbox GL JS & Sì & GeoJSON con \texttt{type: \say{Feature}} \\
OpenLayers & Raccomandato & GeoJSON o oggetti \texttt{ol.Feature} \\
\bottomrule
\end{tabular}
\end{table}

Tre librerie non richiedono GeoJSON (Leaflet, Deck.gl, Folium); tra queste, Deck.gl e Folium supportano nativamente un formato minimale, mentre Leaflet necessita di plugin aggiuntivi \cite{leaflet-doc, deckgl-docs, folium-doc, mapbox-docs, openlayers-doc}.

GeoJSON è un formato aperto per lo scambio di dati geografici basato su JSON, standardizzato per rappresentare entità spaziali con coordinate WGS84. La sua semplicità e diffusione lo rendono uno standard de facto per applicazioni web e GIS \cite{geojson-spec,rfc7946}.

Il backend gestisce i dati tramite l'endpoint \texttt{/data/<csv\_key>}, eseguendo:
\begin{itemize}
  \item verifica dell'esistenza del file e dei permessi utente;
  \item caricamento tramite \texttt{pandas.read\_csv(..., index\_col=0)} \cite{pandas-readcsv};
  \item calcolo del range dei valori per la visualizzazione della heatmap;
  \item selezione della palette di colori con fallback automatico.
\end{itemize}

Il risultato è un JSON pronto per il frontend, senza ulteriori trasformazioni.

\subsection{Benefici della Struttura Piatta}
\label{ss:why-not-geojson}

La conversione da DataFrame a JSON avviene tramite \texttt{to\_dict()}, sfruttando le ottimizzazioni interne di \textit{Pandas} senza cicli espliciti \cite{pandas-performance}. La scelta di non usare GeoJSON garantisce alte prestazioni, semplicità del codice e facilità di debugging, evitando iterazioni riga per riga, creazione manuale delle geometrie e serializzazioni complesse.

Il formato piatto è versatile: oltre alle heatmap, supporta scatter plot, grafici a bolle e visualizzazioni 3D. La struttura libera consente rapide sperimentazioni nel frontend e riduce la complessità architetturale, producendo un sistema leggero, efficiente e conforme agli obiettivi progettuali.

Durante sviluppo e test, il formato si è rivelato immediatamente leggibile in console e nel \textit{logging} server, velocizzando l'identificazione di eventuali problemi.




\subsection{Flusso dei Dati nel Backend}

Riprendendo le rotte presenti in sezione \ref{ss:endpoints}, all'interno dell'endpoint \texttt{/data/<csv\_key>}, i dati vengono letti da file CSV tramite la libreria \texttt{pandas}. Il codice seguente evidenzia il comportamento effettivo del backend:

\begin{listing}[H]
\caption{Lettura e serializzazione dei dati CSV}
\label{lst:csv_reading_serialization} % Ho aggiunto un'etichetta per riferimento
\begin{minted}{python}
df = pd.read_csv(csv_file, index_col=0)
data = df[config.REQUIRED_COLUMNS].to_dict(orient='records')

response_data = {
    'data': data,
    'valueRange': value_range,
    'colorScale': colors,
    'csvKey': csv_key,
    'csvFile': csv_file
}
return jsonify(response_data)
\end{minted}
\end{listing}

I dati vengono poi convertiti in una lista di dizionari Python utilizzando il metodo\\ \texttt{to\_dict(orient='records')} e serializzati in formato JSON. Tale passaggio risulta efficiente per la serializzazione \cite{pandas-todict}. La struttura risultante è piatta e leggibile; segue un esempio di un singolo datapoint in formato JSON:

\begin{listing}[H]
\caption{Formato semplificato JSON}
\label{lst:simplified_json_format} % Added a label for reference
\begin{minted}{json}
{
  "Latitude": 37.2589,
  "Longitude": -59.3,
  "Value": 88.046
}
\end{minted}
\end{listing}

\subsubsection{GeoJSON: Quando e Perché Non Usarlo}

Il formato GeoJSON è largamente utilizzato per rappresentare entità geografiche complesse come poligoni, linee o feature collection. 
Tuttavia, nel caso specifico di dataset composti esclusivamente da punti con attributi numerici, il formato GeoJSON introduce un sovraccarico strutturale (\textit{overhead}) non necessario:

\begin{listing}[H]
\caption{Struttura GeoJSON equivalente}
\label{lst:geojson_equivalent_structure} % Added a label for reference
\begin{minted}{json}
{
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [-59.3, 37.2589]
  },
  "properties": {
    "Value": 88.046
  }
}
\end{minted}
\end{listing}

La struttura semplificata usata nel progetto si è dimostrata, in termini di dimensione del JSON e della sua versione GeoJSON, fino al 70\% più compatta. Questo è particolarmente importante quando si lavora con decine di migliaia di punti da trasmettere al client. Nella sezione \ref{ss:why-not-geojson} si parla in maniera più dettagliata del motivo dietro a tale scelta implementativa.

GeoJSON rimane comunque un formato valido in molti contesti. La sua adozione sarebbe raccomandabile in scenari in cui è necessario rappresentare:

\begin{itemize}
  \item Poligoni e aree di interesse geospaziale;
  \item Linee di migrazione, rotte o percorsi;
  \item Confini amministrativi;
  \item Collezioni eterogenee di oggetti geografici.
\end{itemize}

Nel caso in esame, tuttavia, i dati consistono esclusivamente in punti con attributi associati, per cui un formato più leggero è preferibile.